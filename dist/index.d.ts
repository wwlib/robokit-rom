// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   ../events
//   ../@jibo/apptoolkit-library

declare module 'robokit-rom' {
    import { sum } from 'robokit-rom/sum';
    import IRomApp from 'robokit-rom/rom/IRomApp';
    import RomCommand, { RomCommandData } from 'robokit-rom/rom/RomCommand';
    import RomCommands from 'robokit-rom/rom/RomCommands';
    import Robot, { RobotData, RobotType, RobotIntentData, RobotIntent, RobotIntentType } from 'robokit-rom/robot/Robot';
    export { sum, IRomApp, RomCommand, RomCommandData, RomCommands, Robot, RobotData, RobotType, RobotIntentData, RobotIntent, RobotIntentType };
}

declare module 'robokit-rom/sum' {
    export function sum(a: number, b: number): number;
}

declare module 'robokit-rom/rom/IRomApp' {
    export default interface IRomApp {
        port: number;
        nluDefault: string;
        clientId: string;
        clientSecret: string;
        neo4j_url: string;
        neo4j_user: string;
        neo4j_password: string;
    }
}

declare module 'robokit-rom/rom/RomCommand' {
    export interface RomCommandData {
        name: string;
        type: string;
        data: any;
    }
    export default class RomCommand {
        name: string;
        type: string;
        data: any;
        constructor(name?: string, type?: string, data?: any);
        initWithData(data: RomCommandData): void;
        get json(): RomCommandData;
    }
}

declare module 'robokit-rom/rom/RomCommands' {
    import RomCommand from 'robokit-rom/rom/RomCommand';
    export default class RomCommands {
        commandList: RomCommand[];
        commandMap: Map<string, RomCommand>;
        constructor();
        initWithData(dataList: any[]): void;
        get json(): any;
        get commandNames(): string[];
        getCommandWithName(name: string): RomCommand | undefined;
        addCommand(command: RomCommand): void;
        updateCommandWithName(commandName: string, command: RomCommand): void;
        removeCommand(commandToRemove: RomCommand): void;
    }
}

declare module 'robokit-rom/robot/Robot' {
    import { EventEmitter } from "events";
    import IRomApp from 'robokit-rom/rom/IRomApp';
    import RomCommand from 'robokit-rom/rom/RomCommand';
    import Hub from 'robokit-rom/rom/Hub';
    import RobokitConnection from 'robokit-rom/robot/RobokitConnection';
    import { Account as JiboAccount, AccountCreds as JiboAccountCreds, Robot as JiboRobotConnection } from '@jibo/apptoolkit-library';
    export enum RobotType {
        jibo = "jibo",
        robokit = "robokit"
    }
    export interface RobotData {
        type: string;
        name: string;
        ip: string;
        serialName: string;
        email: string;
        password: string;
    }
    export enum RobotIntentType {
        LAUNCH = 0,
        LISTEN = 1,
        ACTION_COMPLETE = 2
    }
    export interface RobotIntentData {
        nluType: string;
        asr: string;
        intent: string;
        launchId: string | undefined;
        nluData: any | undefined;
        userId: string | undefined;
    }
    export interface RobotIntent {
        robot: Robot;
        type: RobotIntentType;
        data: RobotIntentData;
    }
    export default class Robot extends EventEmitter {
        name: string;
        ip: string;
        serialName: string;
        email: string;
        password: string;
        romApp: IRomApp | undefined;
        protected _connected: boolean;
        protected _targeted: boolean;
        protected _robotConnection: JiboRobotConnection | RobokitConnection | undefined;
        protected _hub: Hub;
        constructor(options?: RobotData);
        get type(): string;
        set type(typeString: string);
        initWithData(data: RobotData): void;
        updateRobotStatusMessages(message: string, subsystem?: string, clearMessages?: boolean): string;
        get number(): number;
        set number(number: number);
        get json(): RobotData;
        updateUserData(userId: string, userName: string): void;
        get userData(): any;
        updateStateData(data: any): any;
        get stateData(): any;
        set stateData(data: any);
        onLaunchIntent(robotIntentData: RobotIntentData): void;
        onListenIntent(robotIntentData: RobotIntentData): void;
        sendCommand(command: RomCommand): void;
        keepAlive(): void;
        clearKeepAlive(): void;
        resetKeepAlive(): void;
        connect(romApp: IRomApp): void;
        loginToAccount(creds: JiboAccountCreds): Promise<JiboAccount>;
        getRobot(account: JiboAccount, name: string): Promise<JiboRobotConnection>;
        disconnect(): void;
        get connected(): boolean;
        get targeted(): boolean;
        get requester(): any | undefined;
        toggleTargeted(): void;
        mute(state?: boolean): void;
    }
}

declare module 'robokit-rom/rom/Hub' {
    import { EventEmitter } from "events";
    import Skill from 'robokit-rom/rom/Skill';
    import Robot from 'robokit-rom/robot/Robot';
    import LUISController from 'robokit-rom/nlu/luis/LUISController';
    import DialogflowControllerV1 from 'robokit-rom/nlu/dialogflow/DialogflowControllerV1';
    export interface HotwordData {
        listenResultEvent: JIBO.v1.ListenResultEvent;
        speaker: any;
    }
    export interface NluData {
        nluType: string;
        asr: string;
        intent: string;
        parameters: any;
    }
    export default class Hub extends EventEmitter {
        robot: Robot;
        skillMap: Map<string, Skill | undefined>;
        launchIntentMap: Map<string, Skill | undefined>;
        hjToken: any;
        dialogflowController: DialogflowControllerV1;
        luisController: LUISController;
        tickInterval: any;
        startTickTime: number;
        previousTickTime: number;
        sessionId: string;
        constructor(robot: Robot);
        tick(): void;
        onRobotConnected(): void;
        registerSkill(skill: Skill): void;
        removeSkill(skill: Skill): void;
        onHotwordEvent(hotwordData: HotwordData): void;
        getLaunchIntent(asr: string): Promise<any>;
        getIntent(asr: string, contexts: string[], nluType: string): Promise<NluData>;
        get robotSerialName(): string;
    }
}

declare module 'robokit-rom/robot/RobokitConnection' {
    import { EventEmitter } from "events";
    import AsyncToken from 'robokit-rom/robot/AsyncToken';
    import AsyncTokenHotword from 'robokit-rom/robot/AsyncTokenHotword';
    import { TransactionMessageData } from 'robokit-rom/rom/Transaction';
    export type HandshakeMessagePayload = {
        status: string;
        connectionString: string;
    };
    export type HandshakeMessage = {
        client: string;
        type: string;
        payload: HandshakeMessagePayload;
        timestamp: number;
    };
    export default class RobokitConnection extends EventEmitter {
        hostname: string;
        port: number;
        connectionString: string;
        webSocket: any;
        robotSerialName: string;
        onHotWordToken: AsyncTokenHotword<any>;
        onListenToken: AsyncToken<any>;
        requester: any;
        constructor(hostname?: string, port?: number);
        connect(): Promise<any>;
        disconnect(): void;
        startWebSocket(): void;
        sendTransactionMessageData(messageData: TransactionMessageData): AsyncToken<any>;
        sendHandshakeMessage(payload: HandshakeMessagePayload): AsyncToken<any>;
        onMessage(message: any): void;
        onRomEvent(message: any): void;
    }
}

declare module 'robokit-rom/rom/Skill' {
    import Robot, { RobotIntentData } from 'robokit-rom/robot/Robot';
    export default abstract class Skill {
        robot: Robot | undefined;
        id: string;
        launchIntent: string;
        running: boolean;
        constructor(robot: Robot | undefined, id: string, launchIntent: string);
        abstract launch(data?: RobotIntentData): void;
        abstract tick(frameTime: number, elapsedTime: number): void;
    }
}

declare module 'robokit-rom/nlu/luis/LUISController' {
    import NLUController, { NLUIntentAndEntities } from 'robokit-rom/rom/NLUController';
    export type LUISIntent = {
        intent: string;
        score: number;
    };
    export type LUISEntity = {
        entity: string;
        type: string;
        startIndex: number;
        endIndex: number;
        resolution: {
            values: string[];
        };
    };
    export type LUISResponse = {
        query: string;
        topScoringIntent: LUISIntent;
        intents: LUISIntent[];
        entities: LUISEntity[];
    };
    export default class LUISController extends NLUController {
        endpoint: string;
        luisAppId: string;
        subscriptionKey: string;
        /**
          * @constructor
          */
        constructor();
        set config(config: any);
        call(query: string): Promise<any>;
        getEntitiesWithResponse(response: LUISResponse): any;
        getIntentAndEntities(query: string, languageCode: string, context: string, sessionId?: string): Promise<NLUIntentAndEntities>;
    }
}

declare module 'robokit-rom/nlu/dialogflow/DialogflowControllerV1' {
    import NLUController, { NLUIntentAndEntities } from 'robokit-rom/rom/NLUController';
    export type DialogflowResponseResultMetadata = {
        intentId: string;
        webhookUsed: boolean;
        webhookForSlotFillingUsed: boolean;
        intentName: string;
    };
    export type DialogflowResponseResultFulfillment = {
        speech: string;
        messages: any;
    };
    export type DialogflowResponseStatus = {
        code: number;
        errorType: string;
        webhookTimedOut: boolean;
    };
    export type DialogflowResponseResult = {
        source: string;
        resolvedQuery: string;
        action: string;
        actionIncomplete: boolean;
        parameters: any;
        contexts: any[];
        metadata: DialogflowResponseResultMetadata;
        fulfillment: DialogflowResponseResultFulfillment;
        score: number;
    };
    export type DialogflowResponse = {
        id: string;
        timestamp: string;
        lang: string;
        result: DialogflowResponseResult;
        status: DialogflowResponseStatus;
        sessionId: number;
    };
    export default class DialogflowControllerV1 extends NLUController {
        apiAuthorization: string;
        /**
          * @constructor
          */
        constructor();
        set config(config: any);
        call(query: string, languageCode: string, context: string, sessionId?: string): Promise<any>;
        getEntitiesWithResponse(response: any): any | undefined;
        getIntentAndEntities(query: string, languageCode: string, context: string, sessionId?: string): Promise<NLUIntentAndEntities>;
    }
}

declare module 'robokit-rom/robot/AsyncToken' {
    import { EventEmitter } from 'events';
    export default class AsyncToken<T> extends EventEmitter {
        complete: Promise<T> | undefined;
        update: any;
        constructor();
    }
}

declare module 'robokit-rom/robot/AsyncTokenHotword' {
    import AsyncToken from 'robokit-rom/robot/AsyncToken';
    export default class AsyncTokenHotword<T> extends AsyncToken<any> {
        hotWordHeard: any;
        constructor();
    }
}

declare module 'robokit-rom/rom/Transaction' {
    import { EventEmitter } from 'events';
    export type TransactionMessageData = {
        client?: string;
        id: number;
        type: string;
        data: any;
        sendTime: number;
    };
    export default class Transaction extends EventEmitter {
        id: string;
        robotSerialName: string;
        status: string;
        type: string;
        data: any;
        sendTime: number;
        receiptTime: number;
        commandReceivedTime: number;
        commandCompletedTime: number;
        receiptPayload: any;
        constructor(id: string, type: string, data: any, robotSerialName: string);
        getMessageDataToSend(): TransactionMessageData;
        getMessageDataToLog(): any;
        onReceipt(payload: any): void;
        destroy(): void;
    }
}

declare module 'robokit-rom/rom/NLUController' {
    export type NLUIntentAndEntities = {
        intent: string;
        entities: any;
    };
    export default abstract class NLUController {
        constructor();
        abstract set config(config: any);
        abstract call(query: string, languageCode: string, context: string, sessionId?: string): Promise<any>;
        abstract getEntitiesWithResponse(response: any): any | undefined;
        abstract getIntentAndEntities(query: string, languageCode: string, context: string, sessionId?: string): Promise<NLUIntentAndEntities>;
    }
}

